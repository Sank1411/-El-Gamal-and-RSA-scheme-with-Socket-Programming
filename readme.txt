El-Gamal Encryption Scheme

Libraries used :
1. gmpy2 for generation of 25 digit (84 bit) prime number and performing modular arithmetic operations such as modular exponent,modular inverse,etc.
2. pyecm to generate prime factors of a large number in a very less time
3 numpy for random number generation

File "El-Gamal Crypto-Scheme.ipynb" is used to demonstrate the working of El-Gamal Scheme. 
It has following parts :
	1. Finding primitive roots (get_primitive_root(prime) function returns a single primitive root) :
		1. If m is a primitive root modulo n ,then the multiplicative order of m is phi(n) i.e m^(phi(n)) is congruent to 1mod(n)
		2. We can use this to test a candidate m to see if it is primitive.
		3. First compute phi(n) and then find it's prime factors using factors function from pyecm library.
		4. Finally compute [m^(phi(n)/ptime_factor) mod(n)] by gmpy2.powmod(m,(phi(n)/ptime_factor),n) for all the prime factors of phi(n).
		5. A number m for which [m^(phi(n)/ptime_factor) mod(n)] for all prime factors are all different from 1 is a primitive root.
	2. Key Generation ( generte_keys() function returns Public Key (e1,e2,p) and Private Key (d) ) :
		1. p : 25 digit (84 bit) prime was generated using gmpy2.next_prime( 10^24+(random_number generated by numpy to generate different prime 
		   for every key generation) )
		2. d is chosen stochastically from the range [2,p-2] (inclusively)
		3. e1 is chosen from primitive roots of p by calling e1 = get_primitive_root(p)
		4. e2 = (e1^d)mod(p) found by using gmpy2.powmod(e1,d,p) method
	3. Encryption : ( encrypt(plain_text_blocks,public_keys) returns cipher_text_blocks )
		1. Since, we are using 25 digit prime for performing modular operations, we can only encrypt 12 characters at a time i.e 24 digits at a time 
			   because each character generates 2 digits.
		2. So, we have to implement El-Gamal as a block cipher with block size of 12 characters (or 24 digit number).
		3. If (p1,p2...,pk) are plain text blocks, then we return ciphertext blocks (c1,c2,........,ck)
	           where c_i = (c_i1,c_i2)
		   c_i1 = (e1^r)mod(p) calculated by gmpy2.powmod(e1,r,p)
		   c_i2 = ((e2^r)*p_i)mod(p) calculated by ((gmpy2.powmod(e2,r,p))*p_i)mod(p)
	4. Decryption : ( decrypt(cipher_text_blocks,public_keys,private_key) returns decrypted_plain_text_blocks )
		1. If (c1,c2...,ck) are plain text blocks, then we return ciphertext blocks (p1,p2,........,pk)
		   where c_i = (c_i1,c_i2)
		   and p_i = (((c_i1)^(-d))*c_i2)mod(p) by (gmpy2.Invert(gmpy2.powmod(c_i1,d,p),p))mod(p)
	
	5. Auxiliary Functions : 
		1. get_blocks(PT) : To convert plain_text string into blocks of plain_text_string using block size
		2. format_plain_text(PT) : Converts blocks of plain_text string returned by get_blocks(PT) into numeric plain_text_blocks
			 To convert characters to 2 digits, their ASCII values along with some modifications was used.
				- ASCII values from 0-31 are not alpha-numeric characters.
				- ASCII values from ***32-99 contain [A_Z,a,b,c] and special characters such as @,#,',",space,etc***
				- ASCII values from 100-126 contain [d-z] which are 3 digit.
				- Since we're not using ASCII values from 0-31, we can convert ASCII values of [d-z] to 2-digit number, 
				  by subtracting 100 from them.
				- If we subtract 100 from ASCII values of 'd', which is 100, we get 00. ***dam will be 009709 which 9709***, so 'd' is lost in the 
				  processing. 
				- Unused ASCII values we have now are [27,28,29,30,31], so we assign d=28. 
		3. format_decrypted_plain_text(decypted_plain_text_blocks) : decypted_plain_text_blocks are numeric decrypted plain text blocks 
                   returned by 'decrypt' function. 
                   format_decrypted_plain_text returns a single string by using ASCII values with some modifications as explained above.


All of these functions : generte_keys(), encrypt(plain_text_blocks,public_keys),decrypt(cipher_text_blocks,public_keys,private_key),get_blocks(PT)
			 format_plain_text(PT),format_decrypted_plain_text(decypted_plain_text_blocks) are copied into 'el_gamal.py' file
el_gamal.py file is then used in files client.ipynb and server.ipynb to perform required operations so that end-to-end encrypted communication 
can be established between client and server.

For Socket-Programming : All the imprtant libraries like pyecm,gmpy2,numpy and functions from el_gamal.py are imported in both 'client.ipynb' and 'server.ipynb'
1. Connection is established between server and client by creating socket.
2. Cluent and Server both generate their own set of public and private keys
3. Client and Server exchange their public keys through the socket to start wnd-to-end encrypted communication.
4. End-to-end encrypted communication between client and server begins.
	-Client encrypts his/her message blockwise using server's public keys and sends it to server
	-Server receives client's encrypted message and decrypts it blockwise using his/her own private key
	-Server now encrypts his/her message blockwise using client's public keys and sends it to client
	-Client receives server's encrypted message and decrypts it blockwise using his/her own private key
	-This process repeates untill either client or server sends the message 'BYE'